# ---------------------------------- NodeConfig
# id of the node
#node.id=

# the consensus protocol that will be used for the node. valid options are 'bizur' or 'raft' (without single quotes)
#node.consensus.protocol=

# ---------------------------------- RaftConfig (extends NodeConfig)
# the initial election timeout for the node. This value will be modified internally based on node's id.
#raft.electionTimeoutMs=5000

# the interval that the node keeps checking for raft state machine internally and sends heartbeat messages.
#raft.updateIntervalMs=500

# the consistency level/guarantee configured for the protocol. Strong consistency guarantee ensures that all the
# reads see the most recent writes (consistency favored over availability during network partitions, i.e. CP system),
# otherwise, availability is favored over data consistency where clients might read previous versions of values
# (AP system).
# Possible values are:
# - strong (default): for CP system setup
# - weak: for AP system setup
# NB! It is strongly recommended to change this value only for demo purposes as weak consistency has not been
# covered with tests.
#raft.consistency=strong

# ---------------------------------- BizurConfig (extends NodeConfig)
# total number of buckets to be used in the bizur alg.
#bizur.numBuckets=1

# the initial election timeout for the node. This value will be modified internally based on node's id.
#bizur.electionTimeoutMs=5000

# the interval that the node keeps checking for raft state machine internally and sends heartbeat messages.
#bizur.updateIntervalMs=500

# ---------------------------------- TransportConfig
# timeout for waiting a response per message.
#transport.message.callbackTimeoutMs=5000

# ---------------------------------- TcpTransportConfig (extends TransportConfig)
# pool size for clients assigned for each node.
# - if value equals 0 (zero), then clientPoolSize=(processor count * 2)
# - if value is less than 0, then clientPoolSize=unlimited. It is advisable to use this value since bizur nodes may
#   reach a deadlock state if not enough number of clients are present.
#transport.tcp.clientPoolSize=-1

# destinations for the tcp transport.
#transport.tcp.destinations=

# port to bind for the tcp server transport.
#transport.tcp.server.port=

# socket read timeout in milliseconds. If you want to disable the timeout, set this value to 0 (zero).
# Default is 30 seconds.
# The reason why this works is that nodes send heartbeat messages to each other in regular intervals, so the
# sockets created are expecting to receive these messages before reaching the timeout.
#transport.tcp.server.socket.so_timeout=30000

# The count of failures/timeouts when trying to connect or communicate with a server to mark it as unstable.
# For all servers that are marked unstable, the client is disallowed from sending messages. The overhead
# of creating a tcp socket connection and trying to send a message that is bound to fail is aimed to be eliminated
# this way. As soon as the failure detector understands that the unstable server is back online, the client may
# continue sending messages.
#transport.tcp.client.failure.markServerAsFailedCount=3

# The interval (in milliseconds) to ping a server which was marked as unstable/failed. The failure detector is
# responsible for pinging all the servers that are marked unstable.
#transport.tcp.client.failure.pingInterval=5000

# ---------------------------------- MetricsConfig
# Enable/disable metrics collection. Disabled by default.
# Metrics are being exported as graphite compatible data. A custom file sender has been implemented for this purpose.
#metrics.enabled=false

# specify the full path of the file to write the metrics.
#metrics.exportfile=/tmp/metrics.txt

# specify the separator (blank space by default) for each metric row. To support csv formatted data, comma (,)
# can be supplied as the value of this property.
#metrics.seperator=

# specify prefix for the collected metrics.
#metrics.prefix=

# step interval to collect metrics (milliseconds), cannot be less than 1000.
#metrics.step=2000

# enable/disable supported jvm metrics.
#metrics.classloader.enabled=true
#metrics.memory.enabled=true
#metrics.gc.enabled=true
#metrics.processor.enabled=true
#metrics.thread.enabled=true